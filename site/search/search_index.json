{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Magma is am efficient, modern and reactive state management library built specifically for Roblox and Luau . Magma is still in beta! Magma is still highly work-in-progress. There are features that may get reworked, removed, added, their behavior change, and so, Magma is still not ready for production However, this is also the perfect time for you to suggest new ideas that will benefit the library.","title":"Home"},{"location":"#home","text":"Magma is am efficient, modern and reactive state management library built specifically for Roblox and Luau . Magma is still in beta! Magma is still highly work-in-progress. There are features that may get reworked, removed, added, their behavior change, and so, Magma is still not ready for production However, this is also the perfect time for you to suggest new ideas that will benefit the library.","title":"Home"},{"location":"Tutorial/","text":"Getting Started Welcome to Magma's Tutorials section! Here, you will learn how to use Magma and it's objects! What do you need to know? This tutorial assumes you are comfortable with Roblox and the luau scripting language These tutorials aren't an introduction to scripting! If you'd like to learn, check out the Roblox DevHub. Installing Magma For Rojo: Go the release you wish to install, and then download the source code zip file, and then copy the src file and rename it to Magma and put it in the shared folder. for Roblox Studio: Go to the release yoou wish to install, and search for the .rbxm file and then download it. After that, place it in the ReplicatedStorage.","title":"Get Started"},{"location":"Tutorial/#getting-started","text":"Welcome to Magma's Tutorials section! Here, you will learn how to use Magma and it's objects!","title":"Getting Started"},{"location":"Tutorial/#what-do-you-need-to-know","text":"This tutorial assumes you are comfortable with Roblox and the luau scripting language These tutorials aren't an introduction to scripting! If you'd like to learn, check out the Roblox DevHub.","title":"What do you need to know?"},{"location":"Tutorial/#installing-magma","text":"For Rojo: Go the release you wish to install, and then download the source code zip file, and then copy the src file and rename it to Magma and put it in the shared folder. for Roblox Studio: Go to the release yoou wish to install, and search for the .rbxm file and then download it. After that, place it in the ReplicatedStorage.","title":"Installing Magma"},{"location":"Tutorial/Basics/Gems/","text":"Storing State Our systems use some data, called \"state\" - Learn how to store this data with Magma. Required Code local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) What is State State is simply the current condition of your application data at a point. An example of this is a Player object, to know how it behaves and looks, we should have the following: Current Health Speed Children etc So, these values are therefore the state of the player object - so if we want to change how the object behaves, we need to use the value of these variables. Storing State To store state, Magma provides you various tools to store your state - one of them, are \"Gems\", these are objects that store singular values that allow for reading and writing. To use Gens, you should first need to import the Gem constructor local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem To create a new Gem object, we need to call the constructor with an optional inital value. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local value = Gem ( 100 ) By default, this newly created gem will error when you set it to a value whose type is different than the old value's type. To change this, pass another boolean with the value of false local value = Gem ( 100 , false ) Now, to read from value , use the value:get() method. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local value = Gem ( 100 ) print ( value : get ()) -- 100 To set it something else, we can use the value:set(input) method. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local value = Gem ( 100 ) print ( value : get ()) -- 100 value : set ( 50 ) print ( value : get ()) -- 50 If we were to set it to something else that has a different type than the old value's, it will error. Keep in mind, that not all value:set() calls actually work - if you were to set the value to the same value, nothing will occur.","title":"Storing State"},{"location":"Tutorial/Basics/Gems/#storing-state","text":"Our systems use some data, called \"state\" - Learn how to store this data with Magma. Required Code local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma )","title":"Storing State"},{"location":"Tutorial/Basics/Gems/#what-is-state","text":"State is simply the current condition of your application data at a point. An example of this is a Player object, to know how it behaves and looks, we should have the following: Current Health Speed Children etc So, these values are therefore the state of the player object - so if we want to change how the object behaves, we need to use the value of these variables.","title":"What is State"},{"location":"Tutorial/Basics/Gems/#storing-state_1","text":"To store state, Magma provides you various tools to store your state - one of them, are \"Gems\", these are objects that store singular values that allow for reading and writing. To use Gens, you should first need to import the Gem constructor local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem To create a new Gem object, we need to call the constructor with an optional inital value. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local value = Gem ( 100 ) By default, this newly created gem will error when you set it to a value whose type is different than the old value's type. To change this, pass another boolean with the value of false local value = Gem ( 100 , false ) Now, to read from value , use the value:get() method. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local value = Gem ( 100 ) print ( value : get ()) -- 100 To set it something else, we can use the value:set(input) method. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local value = Gem ( 100 ) print ( value : get ()) -- 100 value : set ( 50 ) print ( value : get ()) -- 50 If we were to set it to something else that has a different type than the old value's, it will error. Keep in mind, that not all value:set() calls actually work - if you were to set the value to the same value, nothing will occur.","title":"Storing State"},{"location":"Tutorial/Basics/Listeners/","text":"Observing States In our systems, we usually need to listen to changes coming from state objects - Let's learn how Magma's object listener provides us a great, efficient way of listening to these changes. Required Code local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem Listening to Changes To listen to changes coming from other state objects, we use Magma's listener object. To start using listeners, we need to import the listener constructor. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local Listener = Magma . Listener Now, we can create a new Listner, but first, let's create a new Gem object. local health = Gem ( 100 ) Now, we can create a listener for it, which we will name \"healthListener\", and then call the constructor with the health object as an argument. local health = Gem ( 100 ) local healthListener = Listener ( health ) Now, to listen to changes on health, we can use the healthListener:onChange(handler) method. healthListener : onChange ( function ( oldValue , newValue ) print ( oldValue , newValue ) end ) Additionally, Magma offers a syntatic sugar for onChange(0) method. It first calls your handler with (nil, currentValue) , and then calls ...:onChange internally. Moreover, sometimes we need to disconnect these handlers. We can disconnect the handlers by using the Disconnect function returned by both OnChange and OnBind .","title":"Observing State"},{"location":"Tutorial/Basics/Listeners/#observing-states","text":"In our systems, we usually need to listen to changes coming from state objects - Let's learn how Magma's object listener provides us a great, efficient way of listening to these changes. Required Code local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem","title":"Observing States"},{"location":"Tutorial/Basics/Listeners/#listening-to-changes","text":"To listen to changes coming from other state objects, we use Magma's listener object. To start using listeners, we need to import the listener constructor. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local Listener = Magma . Listener Now, we can create a new Listner, but first, let's create a new Gem object. local health = Gem ( 100 ) Now, we can create a listener for it, which we will name \"healthListener\", and then call the constructor with the health object as an argument. local health = Gem ( 100 ) local healthListener = Listener ( health ) Now, to listen to changes on health, we can use the healthListener:onChange(handler) method. healthListener : onChange ( function ( oldValue , newValue ) print ( oldValue , newValue ) end ) Additionally, Magma offers a syntatic sugar for onChange(0) method. It first calls your handler with (nil, currentValue) , and then calls ...:onChange internally. Moreover, sometimes we need to disconnect these handlers. We can disconnect the handlers by using the Disconnect function returned by both OnChange and OnBind .","title":"Listening to Changes"},{"location":"Tutorial/Basics/ReGem/","text":"ReGems ReGems are state objects that we use to derive new data from other ones efficiently - Let's learn how to use them! Required Code 1 2 3 4 local ReplicatedStorage = game : GetStorage ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem Usage To use ReGems, you should get the constructor first: 1 local ReGem = Magma . ReGem To create a regem, you should call the constructor with the prcoesser function that returns a value that accepts a use utility, you will use this function to let ReGem know what objects you are using. Secondly, you can provide a destructor function in the second argument for objects that require manual destruction and/or have a Destroy() method. Additionally, you can use Magma.cleanUp utility as the destructor function. Here is a list of the objects that get handled by cleanUp . 1. Roblox Instances 2. RBXScriptConnection 3. Any table that has a Destroy() method. 1 2 3 4 5 local health = Gem ( 23 ) local midHealth = ReGem ( function ( use ) return use ( health ) / 2 end ) -- No destructor is provided as numbers don't require destruction To read from them, you can use: 1 print ( midHealth : get ()) If you were to update health , midHealth will update too: 1 2 3 health : set ( 50 ) print ( midHealth : get ()) -- 25 Why ReGems? You may ask why can't I just use listener:onBind ? While listeners do work, it is a nightmare when you use more than 1 dependency in a dependent.","title":"Conputing"},{"location":"Tutorial/Basics/ReGem/#regems","text":"ReGems are state objects that we use to derive new data from other ones efficiently - Let's learn how to use them! Required Code 1 2 3 4 local ReplicatedStorage = game : GetStorage ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem","title":"ReGems"},{"location":"Tutorial/Basics/ReGem/#usage","text":"To use ReGems, you should get the constructor first: 1 local ReGem = Magma . ReGem To create a regem, you should call the constructor with the prcoesser function that returns a value that accepts a use utility, you will use this function to let ReGem know what objects you are using. Secondly, you can provide a destructor function in the second argument for objects that require manual destruction and/or have a Destroy() method. Additionally, you can use Magma.cleanUp utility as the destructor function. Here is a list of the objects that get handled by cleanUp . 1. Roblox Instances 2. RBXScriptConnection 3. Any table that has a Destroy() method. 1 2 3 4 5 local health = Gem ( 23 ) local midHealth = ReGem ( function ( use ) return use ( health ) / 2 end ) -- No destructor is provided as numbers don't require destruction To read from them, you can use: 1 print ( midHealth : get ()) If you were to update health , midHealth will update too: 1 2 3 health : set ( 50 ) print ( midHealth : get ()) -- 25","title":"Usage"},{"location":"Tutorial/Basics/ReGem/#why-regems","text":"You may ask why can't I just use listener:onBind ? While listeners do work, it is a nightmare when you use more than 1 dependency in a dependent.","title":"Why ReGems?"},{"location":"Tutorial/Fundamentals/objects/","text":"Why Objects? The Problem Our code is normally managed by internal variables, and when those change, we want our systems to reflect those thanges. However, it isn't really possible to listen to changes from a variable in Lua - So it's often your responsibility to update all parts of code that use those variables. Building Self-Aware Variables To combat this issue, we need to fundamentally extend what variables can do. In particular, we need three additional features: We need to save a list of dependents - other places currently using our variable. This is so we know who to notify when the value changes. We need to save a list of dependencies - other places we are currently using their variables. This is so we know who to notify when we don't need them anymore We need to run some code when the variable is set to a new value. If we can do that, then we can go through the list and notify everyone. Magma introduces the concept of \"state objects\", they are objects that store a list dependents to notify everyone using their values, and optionally a list of dependencies so their dependents can notify them when they don't depend on them anymore.","title":"Why Objects"},{"location":"Tutorial/Fundamentals/objects/#why-objects","text":"","title":"Why Objects?"},{"location":"Tutorial/Fundamentals/objects/#the-problem","text":"Our code is normally managed by internal variables, and when those change, we want our systems to reflect those thanges. However, it isn't really possible to listen to changes from a variable in Lua - So it's often your responsibility to update all parts of code that use those variables.","title":"The Problem"},{"location":"Tutorial/Fundamentals/objects/#building-self-aware-variables","text":"To combat this issue, we need to fundamentally extend what variables can do. In particular, we need three additional features: We need to save a list of dependents - other places currently using our variable. This is so we know who to notify when the value changes. We need to save a list of dependencies - other places we are currently using their variables. This is so we know who to notify when we don't need them anymore We need to run some code when the variable is set to a new value. If we can do that, then we can go through the list and notify everyone. Magma introduces the concept of \"state objects\", they are objects that store a list dependents to notify everyone using their values, and optionally a list of dependencies so their dependents can notify them when they don't depend on them anymore.","title":"Building Self-Aware Variables"},{"location":"Tutorial/Fundamentals/reactive/","text":"Reactive Programming Magma is built on the reactive programming principles, as such, you need to know what exactly is reactive programming, so that you can leverage Magma's features to it's best. It's all about Events In Reactive Programming, you manage data with events, an event is simply enough, a notification that implies something has changed from an object to another, no matter their type. Consider the following pseudocode: object_1 = object ( 23 ) object_2 = object (( object_1 / 2 )) object_1 : set ( 4 ) -- -> { this sends an notification to object_2 saying that it changed } print ( object_2 : get ()) -- 2 If we were to translate this to a diagram, it would look like: flowchart LR object_constructor--> object_1 object_constructor-->object_2 object_1--> id1{{UPDATE}} --> object_2 Worry about data, not updates The beauty about reactive programming, especially when used in Magma, is that you shouldn't worry about updating your variables when their dependencies update. consider the following lua code: local var_1 = 24 local var_2 = var_1 * 2 This would only work once, because if you were to update var_1, you would manually need to update var_2 too. This is easy to fix in this example, but in larger codebases, it is very tedious to fix. In this page, you were introduced to Reactive programming, a paradigm that let's you declare how your variables react to each other.","title":"Reactive Programming"},{"location":"Tutorial/Fundamentals/reactive/#reactive-programming","text":"Magma is built on the reactive programming principles, as such, you need to know what exactly is reactive programming, so that you can leverage Magma's features to it's best.","title":"Reactive Programming"},{"location":"Tutorial/Fundamentals/reactive/#its-all-about-events","text":"In Reactive Programming, you manage data with events, an event is simply enough, a notification that implies something has changed from an object to another, no matter their type. Consider the following pseudocode: object_1 = object ( 23 ) object_2 = object (( object_1 / 2 )) object_1 : set ( 4 ) -- -> { this sends an notification to object_2 saying that it changed } print ( object_2 : get ()) -- 2 If we were to translate this to a diagram, it would look like: flowchart LR object_constructor--> object_1 object_constructor-->object_2 object_1--> id1{{UPDATE}} --> object_2","title":"It's all about Events"},{"location":"Tutorial/Fundamentals/reactive/#worry-about-data-not-updates","text":"The beauty about reactive programming, especially when used in Magma, is that you shouldn't worry about updating your variables when their dependencies update. consider the following lua code: local var_1 = 24 local var_2 = var_1 * 2 This would only work once, because if you were to update var_1, you would manually need to update var_2 too. This is easy to fix in this example, but in larger codebases, it is very tedious to fix. In this page, you were introduced to Reactive programming, a paradigm that let's you declare how your variables react to each other.","title":"Worry about data, not updates"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Magma is an efficient, modern and reactive state management library built specifically for Roblox and Luau . Magma is still in beta! Magma is still in the beta stage, which means that many features may get a new behavior, get removed entirely, or still not implemented., as such, you aren't recommended to use Magma in production unless you will be able to withstand major changes within releases. However, this is also the perfect time for you to suggest new ideas so that we can move from counterproductive patterns!","title":"Home"},{"location":"#home","text":"Magma is an efficient, modern and reactive state management library built specifically for Roblox and Luau . Magma is still in beta! Magma is still in the beta stage, which means that many features may get a new behavior, get removed entirely, or still not implemented., as such, you aren't recommended to use Magma in production unless you will be able to withstand major changes within releases. However, this is also the perfect time for you to suggest new ideas so that we can move from counterproductive patterns!","title":"Home"},{"location":"Tutorial/","text":"Getting Started Welcome to Magma's Tutorials section! Here, you will learn how to use Magma and it's objects! What do you need to know? This tutorial assumes you are comfortable with Roblox and the luau scripting language These tutorials aren't an introduction to scripting! If you'd like to learn, check out the Roblox DevHub. Being comfortable with Reactive programming will help. Installing Magma For Rojo: Go the release you wish to install, and then download the source code zip file, and then copy the src file and rename it to Magma and put it in the shared folder. for Roblox Studio: Go to the release yoou wish to install, and search for the .rbxm file and then download it. After that, place it in the ReplicatedStorage.","title":"Get Started"},{"location":"Tutorial/#getting-started","text":"Welcome to Magma's Tutorials section! Here, you will learn how to use Magma and it's objects!","title":"Getting Started"},{"location":"Tutorial/#what-do-you-need-to-know","text":"This tutorial assumes you are comfortable with Roblox and the luau scripting language These tutorials aren't an introduction to scripting! If you'd like to learn, check out the Roblox DevHub. Being comfortable with Reactive programming will help.","title":"What do you need to know?"},{"location":"Tutorial/#installing-magma","text":"For Rojo: Go the release you wish to install, and then download the source code zip file, and then copy the src file and rename it to Magma and put it in the shared folder. for Roblox Studio: Go to the release yoou wish to install, and search for the .rbxm file and then download it. After that, place it in the ReplicatedStorage.","title":"Installing Magma"},{"location":"Tutorial/Basics/Gems/","text":"Storing State Our systems use some data, called \"state\" - Learn how to store this data with Magma. Required Code local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) What is State State is simply the current condition of your application data at a point. An example of this is a Player object, to know how it behaves and looks, we should have the following: Current Health Speed Children etc So, these values are therefore the state of the player object - so if we want to change how the object behaves, we need to use the value of these variables. Storing State To store state, Magma provides you various tools to store your state - one of them, are \"Gems\", these are objects that store singular values that allow for reading and writing. To use Gens, you should first need to import the Gem constructor local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem To create a new Gem object, we need to call the constructor with an optional inital value. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local value = Gem ( 100 ) By default, this newly created gem will error when you set it to a value whose type is different than the old value's type. To change this, pass another boolean with the value of false local value = Gem ( 100 , false ) Now, to read from value , use the value:get() method. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local value = Gem ( 100 ) print ( value : get ()) -- 100 To set it something else, we can use the value:set(input) method. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local value = Gem ( 100 ) print ( value : get ()) -- 100 value : set ( 50 ) print ( value : get ()) -- 50 If we were to set it to something else that has a different type than the old value's, it will error. Keep in mind, that not all value:set() calls actually work - if you were to set the value to the same value, nothing will occur.","title":"Storing State"},{"location":"Tutorial/Basics/Gems/#storing-state","text":"Our systems use some data, called \"state\" - Learn how to store this data with Magma. Required Code local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma )","title":"Storing State"},{"location":"Tutorial/Basics/Gems/#what-is-state","text":"State is simply the current condition of your application data at a point. An example of this is a Player object, to know how it behaves and looks, we should have the following: Current Health Speed Children etc So, these values are therefore the state of the player object - so if we want to change how the object behaves, we need to use the value of these variables.","title":"What is State"},{"location":"Tutorial/Basics/Gems/#storing-state_1","text":"To store state, Magma provides you various tools to store your state - one of them, are \"Gems\", these are objects that store singular values that allow for reading and writing. To use Gens, you should first need to import the Gem constructor local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem To create a new Gem object, we need to call the constructor with an optional inital value. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local value = Gem ( 100 ) By default, this newly created gem will error when you set it to a value whose type is different than the old value's type. To change this, pass another boolean with the value of false local value = Gem ( 100 , false ) Now, to read from value , use the value:get() method. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local value = Gem ( 100 ) print ( value : get ()) -- 100 To set it something else, we can use the value:set(input) method. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local value = Gem ( 100 ) print ( value : get ()) -- 100 value : set ( 50 ) print ( value : get ()) -- 50 If we were to set it to something else that has a different type than the old value's, it will error. Keep in mind, that not all value:set() calls actually work - if you were to set the value to the same value, nothing will occur.","title":"Storing State"},{"location":"Tutorial/Basics/Listeners/","text":"Observing States In our systems, we usually need to listen to changes coming from state objects - Let's learn how Magma's object listener provides us a great, efficient way of listening to these changes. Required Code local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem Listening to Changes To listen to changes coming from other state objects, we use Magma's listener object. To start using listeners, we need to import the listener constructor. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local Listener = Magma . Listener Now, we can create a new Listner, but first, let's create a new Gem object. local health = Gem ( 100 ) Now, we can create a listener for it, which we will name \"healthListener\", and then call the constructor with the health object as an argument. local health = Gem ( 100 ) local healthListener = Listener ( health ) Now, to listen to changes on health, we can use the healthListener:onChange(handler) method. healthListener : onChange ( function ( oldValue , newValue ) print ( oldValue , newValue ) end ) Additionally, Magma offers a syntatic sugar method for onChange() method, it is onBind() . It first calls your handler with (nil, currentValue) , and then calls ...:onChange internally. Moreover, sometimes we need to disconnect these handlers. We can disconnect the handlers by using the Disconnect function returned by both OnChange and OnBind .","title":"Observing State"},{"location":"Tutorial/Basics/Listeners/#observing-states","text":"In our systems, we usually need to listen to changes coming from state objects - Let's learn how Magma's object listener provides us a great, efficient way of listening to these changes. Required Code local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem","title":"Observing States"},{"location":"Tutorial/Basics/Listeners/#listening-to-changes","text":"To listen to changes coming from other state objects, we use Magma's listener object. To start using listeners, we need to import the listener constructor. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem local Listener = Magma . Listener Now, we can create a new Listner, but first, let's create a new Gem object. local health = Gem ( 100 ) Now, we can create a listener for it, which we will name \"healthListener\", and then call the constructor with the health object as an argument. local health = Gem ( 100 ) local healthListener = Listener ( health ) Now, to listen to changes on health, we can use the healthListener:onChange(handler) method. healthListener : onChange ( function ( oldValue , newValue ) print ( oldValue , newValue ) end ) Additionally, Magma offers a syntatic sugar method for onChange() method, it is onBind() . It first calls your handler with (nil, currentValue) , and then calls ...:onChange internally. Moreover, sometimes we need to disconnect these handlers. We can disconnect the handlers by using the Disconnect function returned by both OnChange and OnBind .","title":"Listening to Changes"},{"location":"Tutorial/Basics/ReGem/","text":"Computing State We often need derived values in our systems and UI, let's learn how Magma's object ReGem provides us a simple way ot acheiving this. Required Code local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem The Computation Problem Usually in our code, we often need \"dervied\" values for our systems/UIs. For example, in a simple leaderstats, we often have: Kills - increases everytime you kill somebody Cash - increases everytime kills increase by 200 If we were to implement this in Magma with Gems and Listeners, we would do: local Kills = Gem ( 0 ) local KillsListener = Listener ( Kills ) local Cash = Gem ( 0 ) KillsListener : onBind ( function ( _ , newValue ) Cash : set ( newValue * 200 ) end ) While this work , this has various issues, including: If we were to introduce more dependencies to Cash , it would be tedious to manage. The relation between Kills and Cash isn't really clear at a first glance. We are creating two objects, one for saving the latest value, and the other for listening to Kills Solution: ReGems To solve this, Magma introduces a special kind of state objects - ReGems . Instead of storing a fixed value, they run a computation whenever any of their dependencies change. To use a ReGem, you first need to import it's constructor: local ReGem = Magma . ReGem To create a new ReGem, we call it's constrcutor with the computation as an function that will receive a utility function called use as an argument - it is used to tell ReGem what objects you are using. local Players = Gem ( 100 ) local doublePlayers = ReGem ( function ( use ) return use ( Players ) * 2 end ) Additionally, you can pass another function as the destructor which will be responsible for cleaning up old values that need to be. local doublePlayers = ReGem ( function ( use ) return use ( Players ) * 2 end , function ( oldValue ) -- do nothing end ) However, to avoid repeating code, you can use the already built-in Magma.cleanUp utility that will clean up the following: Instances RBXScriptConnections Tables with :Destroy() Or, if you don't want to clean up the oldValue entirely (whether it doesn't need to be or it isn't supposed to manage it) , you can just pass nothing or Magma.doNothing . Now, when Players change, doublePlayers will also change: Players : set ( 20 ) print ( doublePlayers : get ()) -- 40","title":"Conputing"},{"location":"Tutorial/Basics/ReGem/#computing-state","text":"We often need derived values in our systems and UI, let's learn how Magma's object ReGem provides us a simple way ot acheiving this. Required Code local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem","title":"Computing State"},{"location":"Tutorial/Basics/ReGem/#the-computation-problem","text":"Usually in our code, we often need \"dervied\" values for our systems/UIs. For example, in a simple leaderstats, we often have: Kills - increases everytime you kill somebody Cash - increases everytime kills increase by 200 If we were to implement this in Magma with Gems and Listeners, we would do: local Kills = Gem ( 0 ) local KillsListener = Listener ( Kills ) local Cash = Gem ( 0 ) KillsListener : onBind ( function ( _ , newValue ) Cash : set ( newValue * 200 ) end ) While this work , this has various issues, including: If we were to introduce more dependencies to Cash , it would be tedious to manage. The relation between Kills and Cash isn't really clear at a first glance. We are creating two objects, one for saving the latest value, and the other for listening to Kills","title":"The Computation Problem"},{"location":"Tutorial/Basics/ReGem/#solution-regems","text":"To solve this, Magma introduces a special kind of state objects - ReGems . Instead of storing a fixed value, they run a computation whenever any of their dependencies change. To use a ReGem, you first need to import it's constructor: local ReGem = Magma . ReGem To create a new ReGem, we call it's constrcutor with the computation as an function that will receive a utility function called use as an argument - it is used to tell ReGem what objects you are using. local Players = Gem ( 100 ) local doublePlayers = ReGem ( function ( use ) return use ( Players ) * 2 end ) Additionally, you can pass another function as the destructor which will be responsible for cleaning up old values that need to be. local doublePlayers = ReGem ( function ( use ) return use ( Players ) * 2 end , function ( oldValue ) -- do nothing end ) However, to avoid repeating code, you can use the already built-in Magma.cleanUp utility that will clean up the following: Instances RBXScriptConnections Tables with :Destroy() Or, if you don't want to clean up the oldValue entirely (whether it doesn't need to be or it isn't supposed to manage it) , you can just pass nothing or Magma.doNothing . Now, when Players change, doublePlayers will also change: Players : set ( 20 ) print ( doublePlayers : get ()) -- 40","title":"Solution: ReGems"},{"location":"Tutorial/Fundamentals/objects/","text":"Why Objects? The Problem Our code is normally managed by internal variables, and when those change, we want our systems to reflect those thanges. However, it isn't really possible to listen to changes from a variable in Lua - So it's often your responsibility to update all parts of code that use those variables. Building Self-Aware Variables To combat this issue, we need to fundamentally extend what variables can do. In particular, we need three additional features: We need to save a list of dependents - other places currently using our variable. This is so we know who to notify when the value changes. We need to save a list of dependencies - other places we are currently using their variables. This is so we know who to notify when we don't need them anymore We need to run some code when the variable is set to a new value. If we can do that, then we can go through the list and notify everyone. Magma introduces the concept of \"state objects\", they are objects that store a list dependents to notify everyone using their values, and optionally a list of dependencies so their dependents can notify them when they don't depend on them anymore.","title":"Why Objects"},{"location":"Tutorial/Fundamentals/objects/#why-objects","text":"","title":"Why Objects?"},{"location":"Tutorial/Fundamentals/objects/#the-problem","text":"Our code is normally managed by internal variables, and when those change, we want our systems to reflect those thanges. However, it isn't really possible to listen to changes from a variable in Lua - So it's often your responsibility to update all parts of code that use those variables.","title":"The Problem"},{"location":"Tutorial/Fundamentals/objects/#building-self-aware-variables","text":"To combat this issue, we need to fundamentally extend what variables can do. In particular, we need three additional features: We need to save a list of dependents - other places currently using our variable. This is so we know who to notify when the value changes. We need to save a list of dependencies - other places we are currently using their variables. This is so we know who to notify when we don't need them anymore We need to run some code when the variable is set to a new value. If we can do that, then we can go through the list and notify everyone. Magma introduces the concept of \"state objects\", they are objects that store a list dependents to notify everyone using their values, and optionally a list of dependencies so their dependents can notify them when they don't depend on them anymore.","title":"Building Self-Aware Variables"},{"location":"Tutorial/Fundamentals/reactive/","text":"Reactive Programming Magma is built on the reactive programming principles, as such, you need to know what exactly is reactive programming, so that you can leverage Magma's features to it's best. It's all about Events In Reactive Programming, we manage data using \"events\", or more simply enough \"notifications\" from an object to another depending on the context. If we were to build a simple kills-cash leaderstats, we would first have a variable called kills and another called cash . Now, no matter how you want to calculate, either by a static value (kills * 200) or a dynamic value (kills * random) , you would always need to bind the cash to the kills variable. With Magma (aka, reactive programming) , we would use the ReGem and the Gems objects, and it would look like this: local kills = Gem ( 1 ) local cash = ReGem ( function ( use ) return use ( kills ) * 200 end ) Now everything is clear at the first glance, and quite frankly, we have now a variable that is synced to to another! Now, when we change kills , it will update cash , like the following: kills : set ( 20 ) print ( kills : get ()) -- 20,000 Internally, when you use the set() method, kills will send a notification to cash , at which cash responds by upating itself, which we can express in a diagram like this: flowchart LR object_1--> id1{{UPDATE}} --> object_2 Real Behavior The actual behavior in Magma is that for example kills doesn't send \"notification\", but rather directly updates them instead. This difference is minor and doesn't change how you would code with Magma. Worry about data, not updates The beauty about reactive programming, especially when used in Magma, is that you shouldn't worry about updating your variables when their dependencies update. consider the following lua code: local var_1 = 24 local var_2 = var_1 * 2 This would only work once, because if you were to update var_1, you would manually need to update var_2 too. This is easy to fix in this example, but in larger codebases, it is very tedious to fix. In this page, you were introduced to Reactive programming, a paradigm that let's you declare how your variables react to each other.","title":"Reactive Programming"},{"location":"Tutorial/Fundamentals/reactive/#reactive-programming","text":"Magma is built on the reactive programming principles, as such, you need to know what exactly is reactive programming, so that you can leverage Magma's features to it's best.","title":"Reactive Programming"},{"location":"Tutorial/Fundamentals/reactive/#its-all-about-events","text":"In Reactive Programming, we manage data using \"events\", or more simply enough \"notifications\" from an object to another depending on the context. If we were to build a simple kills-cash leaderstats, we would first have a variable called kills and another called cash . Now, no matter how you want to calculate, either by a static value (kills * 200) or a dynamic value (kills * random) , you would always need to bind the cash to the kills variable. With Magma (aka, reactive programming) , we would use the ReGem and the Gems objects, and it would look like this: local kills = Gem ( 1 ) local cash = ReGem ( function ( use ) return use ( kills ) * 200 end ) Now everything is clear at the first glance, and quite frankly, we have now a variable that is synced to to another! Now, when we change kills , it will update cash , like the following: kills : set ( 20 ) print ( kills : get ()) -- 20,000 Internally, when you use the set() method, kills will send a notification to cash , at which cash responds by upating itself, which we can express in a diagram like this: flowchart LR object_1--> id1{{UPDATE}} --> object_2 Real Behavior The actual behavior in Magma is that for example kills doesn't send \"notification\", but rather directly updates them instead. This difference is minor and doesn't change how you would code with Magma.","title":"It's all about Events"},{"location":"Tutorial/Fundamentals/reactive/#worry-about-data-not-updates","text":"The beauty about reactive programming, especially when used in Magma, is that you shouldn't worry about updating your variables when their dependencies update. consider the following lua code: local var_1 = 24 local var_2 = var_1 * 2 This would only work once, because if you were to update var_1, you would manually need to update var_2 too. This is easy to fix in this example, but in larger codebases, it is very tedious to fix. In this page, you were introduced to Reactive programming, a paradigm that let's you declare how your variables react to each other.","title":"Worry about data, not updates"},{"location":"Tutorial/Further/Match/","text":"State Matching We often need some objects that return specific values depending on a new input from another object - Learn how to use Magma's new object \"Match\" to create switch/match-like state objects efficiently Required Code local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem What is State Matching? If you ever coded in a language like javascript, you would be aware of the \"switch\" statement. This statement is like a if-elesif-else statement, but in written in a more readable format. However, how is this any useful in a state management library? The thing is, that we often need values that result after a new input coming from the root dependency, for example, a top-secret laboratory that will allow you in if you inserted the \"right\" combination of numbers. Workaround: ReGems? It's definitely possible do this with Gems and ReGems, while acheiving the same behavior. Consider the following example: local input = Gem ( 3 ) local output = ReGem ( function ( use ) local current_input = use ( input ) if current_input == 2 then return true else return false end end ) This works , but is extremely unintuitive. There are multiple issus with this kind of thing: If our specific case is served by an elseif right before else , then we would be wasting computational power to reach it. What if we were to introduce dependencies into this? No matter how you do it, you would just need to call use on all of them, making output update when there won't be a difference. Solution: Match To solve this, Magma introduces another type of state objects - \"Match\". These are objects that built from the ground to satisfy the following goals: Proper Dependency support Easy syntax Constant lookup for the rightful cases, decreasing the time for searching the case we need To use Match , we first need to import it's constructor: local Match = Magma . Match To create a new Match object, we need to call the constructor with the input object and a conidition table. local input = Gem ( 123 ) local output = Match ( input , { }) Now, let's fill it with the following cases: Case 100: returns 200 Case 200: returns 100 default: return input local input = Gem ( 123 ) local output = Match ( input , { [ 100 ] = function () return 100 * 2 end , [ 200 ] = function () return 200 / 2 end , [ \"default\" ] = function () return input : get () end }) To read from output , we use the output:get() method! print ( output : get ()) -- 123 However, the Match objects also introduces a better dependency support. To use a dependency for a case, we use the use utility that is provided to use in the cases' functions arguments. local input = Gem ( 123 ) local another_dependency = Gem ( 343 ) local output = Match ( input , { [ 100 ] = function () return 100 * 2 end , [ 200 ] = function () return 200 / 2 end , [ \"default\" ] = function ( use ) return input : get () * use ( another_dependency ) end }) Default is required The default case is required, and omitting it will return in an error. This is because right after the case for the input isn't found, it will search for the defualt case instead. Now, our default case will now return input * another_dependency . Let's get back to the goals that this object was created to satisfy: Proper Dependency Support: Using dependencies will no longer cause unneeded updating - Match objects will update when one of the dependencies for the current-used case updates. Super easy syntax: There isn't an easier syntax than this. Constant lookup; No matter the number of your cases, it is O(1) if there is a specified case, and O(2) when there isn't case for the input and Match searches for the default case.","title":"State Matching"},{"location":"Tutorial/Further/Match/#state-matching","text":"We often need some objects that return specific values depending on a new input from another object - Learn how to use Magma's new object \"Match\" to create switch/match-like state objects efficiently Required Code local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Magma = require ( ReplicatedStorage . Magma ) local Gem = Magma . Gem","title":"State Matching"},{"location":"Tutorial/Further/Match/#what-is-state-matching","text":"If you ever coded in a language like javascript, you would be aware of the \"switch\" statement. This statement is like a if-elesif-else statement, but in written in a more readable format. However, how is this any useful in a state management library? The thing is, that we often need values that result after a new input coming from the root dependency, for example, a top-secret laboratory that will allow you in if you inserted the \"right\" combination of numbers.","title":"What is State Matching?"},{"location":"Tutorial/Further/Match/#workaround-regems","text":"It's definitely possible do this with Gems and ReGems, while acheiving the same behavior. Consider the following example: local input = Gem ( 3 ) local output = ReGem ( function ( use ) local current_input = use ( input ) if current_input == 2 then return true else return false end end ) This works , but is extremely unintuitive. There are multiple issus with this kind of thing: If our specific case is served by an elseif right before else , then we would be wasting computational power to reach it. What if we were to introduce dependencies into this? No matter how you do it, you would just need to call use on all of them, making output update when there won't be a difference.","title":"Workaround: ReGems?"},{"location":"Tutorial/Further/Match/#solution-match","text":"To solve this, Magma introduces another type of state objects - \"Match\". These are objects that built from the ground to satisfy the following goals: Proper Dependency support Easy syntax Constant lookup for the rightful cases, decreasing the time for searching the case we need To use Match , we first need to import it's constructor: local Match = Magma . Match To create a new Match object, we need to call the constructor with the input object and a conidition table. local input = Gem ( 123 ) local output = Match ( input , { }) Now, let's fill it with the following cases: Case 100: returns 200 Case 200: returns 100 default: return input local input = Gem ( 123 ) local output = Match ( input , { [ 100 ] = function () return 100 * 2 end , [ 200 ] = function () return 200 / 2 end , [ \"default\" ] = function () return input : get () end }) To read from output , we use the output:get() method! print ( output : get ()) -- 123 However, the Match objects also introduces a better dependency support. To use a dependency for a case, we use the use utility that is provided to use in the cases' functions arguments. local input = Gem ( 123 ) local another_dependency = Gem ( 343 ) local output = Match ( input , { [ 100 ] = function () return 100 * 2 end , [ 200 ] = function () return 200 / 2 end , [ \"default\" ] = function ( use ) return input : get () * use ( another_dependency ) end }) Default is required The default case is required, and omitting it will return in an error. This is because right after the case for the input isn't found, it will search for the defualt case instead. Now, our default case will now return input * another_dependency . Let's get back to the goals that this object was created to satisfy: Proper Dependency Support: Using dependencies will no longer cause unneeded updating - Match objects will update when one of the dependencies for the current-used case updates. Super easy syntax: There isn't an easier syntax than this. Constant lookup; No matter the number of your cases, it is O(1) if there is a specified case, and O(2) when there isn't case for the input and Match searches for the default case.","title":"Solution: Match"}]}